// SPDX-License-Identifier: GPL-3.0-only
//
#include <gui/Plot.h>

#include <wx/rawbmp.h>

#include <algorithm>
#include <cassert>
#include <cstring>
#include <stdexcept>
#include <string>

namespace id::gui
{

enum
{
    PLOT_TIMER_ID = 1
};

wxIMPLEMENT_DYNAMIC_CLASS(Plot, wxControl);

static const Byte FONT_8x8[8][1024 / 8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        0x14, 0x14, 0x08, 0x00, 0x18, 0x08, 0x04, 0x10, 0x08, 0x08, 0x00, 0x00, 0x00, 0x01, 0x1C, 0x08, 0x1C,
        0x1C, 0x0C, 0x3E, 0x1C, 0x3E, 0x1C, 0x1C, 0x00, 0x00, 0x04, 0x00, 0x20, 0x1C, 0x1C, 0x1C, 0x3C, 0x1C,
        0x3C, 0x3E, 0x3E, 0x1C, 0x22, 0x1C, 0x0E, 0x22, 0x10, 0x41, 0x22, 0x1C, 0x1C, 0x1C, 0x3C, 0x1C, 0x3E,
        0x22, 0x22, 0x41, 0x22, 0x22, 0x3E, 0x1C, 0x40, 0x1C, 0x08, 0x00, 0x10, 0x00, 0x10, 0x00, 0x02, 0x00,
        0x0C, 0x00, 0x20, 0x00, 0x00, 0x20, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x0C, 0x08, 0x30, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        0x14, 0x14, 0x1E, 0x32, 0x28, 0x08, 0x08, 0x08, 0x49, 0x08, 0x00, 0x00, 0x00, 0x02, 0x22, 0x18, 0x22,
        0x22, 0x14, 0x20, 0x22, 0x02, 0x22, 0x22, 0x0C, 0x0C, 0x08, 0x00, 0x10, 0x22, 0x22, 0x22, 0x22, 0x22,
        0x22, 0x20, 0x20, 0x22, 0x22, 0x08, 0x04, 0x22, 0x10, 0x63, 0x32, 0x22, 0x12, 0x22, 0x22, 0x22, 0x08,
        0x22, 0x22, 0x41, 0x22, 0x22, 0x02, 0x10, 0x20, 0x04, 0x14, 0x00, 0x08, 0x1C, 0x10, 0x00, 0x02, 0x00,
        0x12, 0x00, 0x20, 0x08, 0x08, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x10, 0x08, 0x08, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x7F, 0x28, 0x34, 0x10, 0x00, 0x10, 0x04, 0x2A, 0x08, 0x00, 0x00, 0x00, 0x04, 0x22, 0x08, 0x02,
        0x02, 0x24, 0x20, 0x20, 0x04, 0x22, 0x22, 0x0C, 0x0C, 0x10, 0x7F, 0x08, 0x02, 0x2E, 0x22, 0x22, 0x20,
        0x22, 0x20, 0x20, 0x20, 0x22, 0x08, 0x04, 0x24, 0x10, 0x55, 0x2A, 0x22, 0x12, 0x22, 0x22, 0x20, 0x08,
        0x22, 0x22, 0x41, 0x14, 0x14, 0x04, 0x10, 0x10, 0x04, 0x22, 0x00, 0x00, 0x02, 0x1C, 0x1C, 0x0E, 0x1C,
        0x10, 0x1D, 0x2C, 0x00, 0x00, 0x24, 0x08, 0xB6, 0x2C, 0x1C, 0x2C, 0x1A, 0x2C, 0x1C, 0x1C, 0x24, 0x22,
        0x41, 0x22, 0x12, 0x3C, 0x10, 0x08, 0x08, 0x30, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x14, 0x1C, 0x08, 0x28, 0x00, 0x10, 0x04, 0x1C, 0x7F, 0x00, 0x7F, 0x00, 0x08, 0x2A, 0x08, 0x04,
        0x0C, 0x3E, 0x3C, 0x3C, 0x08, 0x1C, 0x1E, 0x00, 0x00, 0x20, 0x00, 0x04, 0x04, 0x2A, 0x3E, 0x3C, 0x20,
        0x22, 0x3C, 0x3E, 0x2E, 0x3E, 0x08, 0x04, 0x38, 0x10, 0x49, 0x2A, 0x22, 0x1C, 0x22, 0x3C, 0x1C, 0x08,
        0x22, 0x14, 0x2A, 0x08, 0x08, 0x08, 0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x1E, 0x12, 0x20, 0x12, 0x22,
        0x38, 0x22, 0x32, 0x08, 0x08, 0x28, 0x08, 0x49, 0x12, 0x22, 0x12, 0x24, 0x30, 0x20, 0x08, 0x24, 0x22,
        0x41, 0x14, 0x12, 0x04, 0x20, 0x08, 0x04, 0x49, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x7F, 0x0A, 0x16, 0x46, 0x00, 0x10, 0x04, 0x2A, 0x08, 0x0C, 0x00, 0x00, 0x10, 0x22, 0x08, 0x08,
        0x02, 0x04, 0x02, 0x22, 0x10, 0x22, 0x02, 0x0C, 0x0C, 0x10, 0x7F, 0x08, 0x08, 0x2E, 0x22, 0x22, 0x20,
        0x22, 0x20, 0x20, 0x22, 0x22, 0x08, 0x24, 0x24, 0x10, 0x41, 0x26, 0x22, 0x10, 0x22, 0x28, 0x02, 0x08,
        0x22, 0x14, 0x2A, 0x14, 0x08, 0x10, 0x10, 0x04, 0x04, 0x00, 0x00, 0x00, 0x22, 0x12, 0x20, 0x12, 0x3E,
        0x10, 0x22, 0x22, 0x08, 0x08, 0x30, 0x08, 0x49, 0x12, 0x22, 0x12, 0x24, 0x20, 0x18, 0x08, 0x24, 0x22,
        0x49, 0x08, 0x12, 0x08, 0x10, 0x08, 0x08, 0x06, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x14, 0x3C, 0x26, 0x44, 0x00, 0x08, 0x08, 0x49, 0x08, 0x0C, 0x00, 0x0C, 0x20, 0x22, 0x08, 0x10,
        0x22, 0x04, 0x22, 0x22, 0x10, 0x22, 0x22, 0x0C, 0x0C, 0x08, 0x00, 0x10, 0x00, 0x20, 0x22, 0x22, 0x22,
        0x22, 0x20, 0x20, 0x22, 0x22, 0x08, 0x24, 0x22, 0x10, 0x41, 0x22, 0x22, 0x10, 0x22, 0x24, 0x22, 0x08,
        0x22, 0x08, 0x14, 0x22, 0x08, 0x20, 0x10, 0x02, 0x04, 0x00, 0x00, 0x00, 0x22, 0x12, 0x20, 0x12, 0x20,
        0x10, 0x1E, 0x22, 0x08, 0x08, 0x28, 0x08, 0x41, 0x12, 0x22, 0x1C, 0x1C, 0x20, 0x04, 0x08, 0x24, 0x14,
        0x55, 0x14, 0x0E, 0x10, 0x10, 0x08, 0x08, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x14, 0x08, 0x00, 0x3A, 0x00, 0x04, 0x10, 0x08, 0x08, 0x04, 0x00, 0x0C, 0x40, 0x1C, 0x1C, 0x3E,
        0x1C, 0x0E, 0x1C, 0x1C, 0x10, 0x1C, 0x1C, 0x00, 0x04, 0x04, 0x00, 0x20, 0x08, 0x1C, 0x22, 0x3C, 0x1C,
        0x3C, 0x3E, 0x20, 0x1C, 0x22, 0x1C, 0x18, 0x22, 0x1E, 0x41, 0x22, 0x1C, 0x10, 0x1C, 0x22, 0x1C, 0x08,
        0x1C, 0x08, 0x14, 0x22, 0x08, 0x3E, 0x1C, 0x01, 0x1C, 0x00, 0x00, 0x00, 0x1D, 0x2C, 0x1C, 0x0D, 0x1C,
        0x10, 0x02, 0x22, 0x08, 0x08, 0x24, 0x08, 0x41, 0x12, 0x1C, 0x10, 0x04, 0x20, 0x38, 0x08, 0x1A, 0x08,
        0x22, 0x22, 0x02, 0x3C, 0x0C, 0x08, 0x30, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x1C, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};

void Plot::set_dirty_region(const wxRect &rect)
{
    if (m_dirty_region.IsEmpty())
    {
        m_dirty_region = wxRect{rect};
    }
    else
    {
        m_dirty_region.Union(wxRect{rect});
    }
    m_dirty = true;
}

/* init_pixels
 *
 * Resize the pixel array to sxdots by sydots and initialize it to zero.
 * Any existing pixel array is freed.
 */
void Plot::init_pixels()
{
    m_pixels.clear();
    m_saved_pixels.clear();
    m_pixels.resize(m_width*m_height);
    std::memset(m_pixels.data(), 0, m_pixels.size());
    m_dirty = false;
    m_dirty_region = wxRect{};
}

Plot::Plot(wxWindow *parent, const wxWindowID id, const wxPoint &pos, const wxSize &size, const long style) :
    wxControl(parent, id, pos, size, style),
    m_width(size.GetWidth()),
    m_height(size.GetHeight()),
    m_rendering(m_width, m_height),
    m_font(8, wxFONTFAMILY_TELETYPE, wxFONTSTYLE_NORMAL, wxFONTWEIGHT_NORMAL)
{
    init_pixels();
    Bind(wxEVT_PAINT, &Plot::on_paint, this, GetId());
    for (int i = 0; i < 256; ++i)
    {
        m_clut[i][0] = static_cast<Byte>(i); // R
        m_clut[i][1] = static_cast<Byte>(i); // G
        m_clut[i][2] = static_cast<Byte>(i); // B
    }
    update_palette();
}

void Plot::on_paint(wxPaintEvent &event)
{
    wxPaintDC dc(this);
    dc.DrawBitmap(m_rendering, 0, 0, false);
}

void Plot::write_pixel(int x, int y, const int color)
{
    if (x < 0 || x > m_width || y < 0 || y > m_height)
    {
        return;
    }

    assert(m_pixels.size() == static_cast<size_t>(m_width * m_height));
    m_pixels[(m_height - y - 1) * m_width + x] = static_cast<Byte>(color & 0xFF);

    const wxNativePixelData data{m_rendering};
    assert(data.GetWidth() == m_width);
    assert(data.GetHeight() == m_height);
    auto it = data.GetPixels();
    it.MoveTo(data, x, y);
    it.Red() = m_clut[color][0];
    it.Green() = m_clut[color][1];
    it.Blue() = m_clut[color][2];
    set_dirty_region({x, y, 1, 1});
}

int Plot::read_pixel(const int x, const int y)
{
    assert(m_pixels.size() == static_cast<size_t>(m_width * m_height));
    if (x < 0 || x > m_width || y < 0 || y > m_height)
    {
        return 0;
    }
    return m_pixels[(m_height - 1 - y) * m_width + x];
}

void Plot::write_span(int y, int x, const int last_x, const Byte *pixels)
{
    if (x < 0 || x >= m_width || y < 0 || y >= m_height || last_x < x || last_x >= m_width)
    {
        assert(x >= 0 || x < m_width || y >= 0 || y < m_height || last_x >= x || last_x < m_width);
        return;
    }

    const int width = last_x - x + 1;
    {
        assert(m_pixels.size() == static_cast<size_t>(m_width * m_height));
        Byte *begin{m_pixels.data() + (m_height - 1 - y) * m_width + x};
        std::copy_n(pixels, width, begin);
    }
    {
        const wxNativePixelData data{m_rendering};
        assert(data.GetWidth() == m_width);
        assert(data.GetHeight() == m_height);
        auto it = data.GetPixels();
        it.MoveTo(data, x, y);
        for (int i = 0; i < width; ++i, ++it, ++pixels)
        {
            const Byte color = *pixels;
            it.Red() = m_clut[color][0];
            it.Green() = m_clut[color][1];
            it.Blue() = m_clut[color][2];
        }
    }
    set_dirty_region({x, y, width, 1});
}

void Plot::flush()
{
    if (m_dirty)
    {
        RefreshRect(m_dirty_region, false);
        m_dirty = false;
        m_dirty_region = wxRect{};
    }
}

void Plot::read_span(const int y, const int x, const int last_x, Byte *pixels)
{
    flush();
    const int width = last_x - x + 1;
    for (int i = 0; i < width; i++)
    {
        pixels[i] = read_pixel(x + i, y);
    }
}

void Plot::set_line_mode(int mode)
{
}

void Plot::draw_line(int x1, int y1, int x2, int y2, int color)
{
#if 0
    ::id::draw_line(x1, y1, x2, y2, color);
#endif
}

Colormap Plot::get_colormap() const
{
    return m_clut;
}

void Plot::update_palette()
{
    std::array<Byte, 256> red;
    std::array<Byte, 256> green;
    std::array<Byte, 256> blue;
    for (int i = 0; i < 256; ++i)
    {
        red[i] = m_clut[i][0];
        green[i] = m_clut[i][1];
        blue[i] = m_clut[i][2];
    }
    SetPalette(wxPalette(256, red.data(), green.data(), blue.data()));
}

void Plot::set_colormap(const Colormap &value)
{
    m_clut = value;
    update_palette();
}

void Plot::schedule_alarm(int secs)
{
#if 0
    UINT_PTR result = SetTimer(m_window, PLOT_TIMER_ID, secs, redraw_window);
    if (!result)
    {
        const DWORD error = GetLastError();
        throw std::runtime_error("SetTimer failed: " + std::to_string(error));
    }
#endif
}

void Plot::clear()
{
    m_dirty_region = wxRect{0, 0, m_width, m_height};
    m_dirty = true;
    std::memset(m_pixels.data(), 0, m_pixels.size());
}

void Plot::redraw()
{
    Refresh(false);
}

void Plot::display_string(const int x, const int y, const int fg, const int bg, const char *text)
{
    wxClientDC dc(this);
    dc.SetFont(m_font);
    dc.SetTextBackground(wxColor(m_clut[bg][0], m_clut[bg][1], m_clut[bg][2]));
    dc.SetTextForeground(wxColor(m_clut[fg][0], m_clut[fg][1], m_clut[fg][2]));
    const wxSize sz{dc.GetTextExtent(text)};
    dc.DrawText(text, x, y);
    //set_dirty_region({x, y, sz.GetWidth(), sz.GetHeight()});
    //flush();
}

void Plot::save_graphics()
{
    m_saved_pixels = m_pixels;
}

void Plot::restore_graphics()
{
    m_pixels = m_saved_pixels;
    redraw();
}

void Plot::DoSetSize(const int x, const int y, int width, int height, const int flags)
{
    m_width = width;
    m_height = height;
    wxControl::DoSetSize(x, y, width, height, flags | wxSIZE_FORCE);
    m_rendering = wxBitmap(m_width, m_height);
    init_pixels();
}

wxSize Plot::DoGetBestSize() const
{
    return {m_width, m_height};
}

wxSize Plot::GetMinSize() const
{
    return {m_width, m_height};
}

wxSize Plot::GetMaxSize() const
{
    return {m_width, m_height};
}

} // namespace id::gui

// SPDX-License-Identifier: GPL-3.0-only
//
#include "Plot.h"

#include "3d/plot3d.h"
#include "engine/id_data.h"
#include "misc/version.h"
#include "ui/rotate.h"

#include <windowsx.h>

#include <cassert>
#include <cstring>
#include <stdexcept>
#include <string>

namespace ui
{

enum
{
    PLOT_TIMER_ID = 1
};

static Plot *s_plot{};
static const char *const WINDOW_CLASS{"IdPlot"};

static const Byte FONT_8x8[8][1024 / 8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        0x14, 0x14, 0x08, 0x00, 0x18, 0x08, 0x04, 0x10, 0x08, 0x08, 0x00, 0x00, 0x00, 0x01, 0x1C, 0x08, 0x1C,
        0x1C, 0x0C, 0x3E, 0x1C, 0x3E, 0x1C, 0x1C, 0x00, 0x00, 0x04, 0x00, 0x20, 0x1C, 0x1C, 0x1C, 0x3C, 0x1C,
        0x3C, 0x3E, 0x3E, 0x1C, 0x22, 0x1C, 0x0E, 0x22, 0x10, 0x41, 0x22, 0x1C, 0x1C, 0x1C, 0x3C, 0x1C, 0x3E,
        0x22, 0x22, 0x41, 0x22, 0x22, 0x3E, 0x1C, 0x40, 0x1C, 0x08, 0x00, 0x10, 0x00, 0x10, 0x00, 0x02, 0x00,
        0x0C, 0x00, 0x20, 0x00, 0x00, 0x20, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x0C, 0x08, 0x30, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        0x14, 0x14, 0x1E, 0x32, 0x28, 0x08, 0x08, 0x08, 0x49, 0x08, 0x00, 0x00, 0x00, 0x02, 0x22, 0x18, 0x22,
        0x22, 0x14, 0x20, 0x22, 0x02, 0x22, 0x22, 0x0C, 0x0C, 0x08, 0x00, 0x10, 0x22, 0x22, 0x22, 0x22, 0x22,
        0x22, 0x20, 0x20, 0x22, 0x22, 0x08, 0x04, 0x22, 0x10, 0x63, 0x32, 0x22, 0x12, 0x22, 0x22, 0x22, 0x08,
        0x22, 0x22, 0x41, 0x22, 0x22, 0x02, 0x10, 0x20, 0x04, 0x14, 0x00, 0x08, 0x1C, 0x10, 0x00, 0x02, 0x00,
        0x12, 0x00, 0x20, 0x08, 0x08, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x10, 0x08, 0x08, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x7F, 0x28, 0x34, 0x10, 0x00, 0x10, 0x04, 0x2A, 0x08, 0x00, 0x00, 0x00, 0x04, 0x22, 0x08, 0x02,
        0x02, 0x24, 0x20, 0x20, 0x04, 0x22, 0x22, 0x0C, 0x0C, 0x10, 0x7F, 0x08, 0x02, 0x2E, 0x22, 0x22, 0x20,
        0x22, 0x20, 0x20, 0x20, 0x22, 0x08, 0x04, 0x24, 0x10, 0x55, 0x2A, 0x22, 0x12, 0x22, 0x22, 0x20, 0x08,
        0x22, 0x22, 0x41, 0x14, 0x14, 0x04, 0x10, 0x10, 0x04, 0x22, 0x00, 0x00, 0x02, 0x1C, 0x1C, 0x0E, 0x1C,
        0x10, 0x1D, 0x2C, 0x00, 0x00, 0x24, 0x08, 0xB6, 0x2C, 0x1C, 0x2C, 0x1A, 0x2C, 0x1C, 0x1C, 0x24, 0x22,
        0x41, 0x22, 0x12, 0x3C, 0x10, 0x08, 0x08, 0x30, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x14, 0x1C, 0x08, 0x28, 0x00, 0x10, 0x04, 0x1C, 0x7F, 0x00, 0x7F, 0x00, 0x08, 0x2A, 0x08, 0x04,
        0x0C, 0x3E, 0x3C, 0x3C, 0x08, 0x1C, 0x1E, 0x00, 0x00, 0x20, 0x00, 0x04, 0x04, 0x2A, 0x3E, 0x3C, 0x20,
        0x22, 0x3C, 0x3E, 0x2E, 0x3E, 0x08, 0x04, 0x38, 0x10, 0x49, 0x2A, 0x22, 0x1C, 0x22, 0x3C, 0x1C, 0x08,
        0x22, 0x14, 0x2A, 0x08, 0x08, 0x08, 0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x1E, 0x12, 0x20, 0x12, 0x22,
        0x38, 0x22, 0x32, 0x08, 0x08, 0x28, 0x08, 0x49, 0x12, 0x22, 0x12, 0x24, 0x30, 0x20, 0x08, 0x24, 0x22,
        0x41, 0x14, 0x12, 0x04, 0x20, 0x08, 0x04, 0x49, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x7F, 0x0A, 0x16, 0x46, 0x00, 0x10, 0x04, 0x2A, 0x08, 0x0C, 0x00, 0x00, 0x10, 0x22, 0x08, 0x08,
        0x02, 0x04, 0x02, 0x22, 0x10, 0x22, 0x02, 0x0C, 0x0C, 0x10, 0x7F, 0x08, 0x08, 0x2E, 0x22, 0x22, 0x20,
        0x22, 0x20, 0x20, 0x22, 0x22, 0x08, 0x24, 0x24, 0x10, 0x41, 0x26, 0x22, 0x10, 0x22, 0x28, 0x02, 0x08,
        0x22, 0x14, 0x2A, 0x14, 0x08, 0x10, 0x10, 0x04, 0x04, 0x00, 0x00, 0x00, 0x22, 0x12, 0x20, 0x12, 0x3E,
        0x10, 0x22, 0x22, 0x08, 0x08, 0x30, 0x08, 0x49, 0x12, 0x22, 0x12, 0x24, 0x20, 0x18, 0x08, 0x24, 0x22,
        0x49, 0x08, 0x12, 0x08, 0x10, 0x08, 0x08, 0x06, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x14, 0x3C, 0x26, 0x44, 0x00, 0x08, 0x08, 0x49, 0x08, 0x0C, 0x00, 0x0C, 0x20, 0x22, 0x08, 0x10,
        0x22, 0x04, 0x22, 0x22, 0x10, 0x22, 0x22, 0x0C, 0x0C, 0x08, 0x00, 0x10, 0x00, 0x20, 0x22, 0x22, 0x22,
        0x22, 0x20, 0x20, 0x22, 0x22, 0x08, 0x24, 0x22, 0x10, 0x41, 0x22, 0x22, 0x10, 0x22, 0x24, 0x22, 0x08,
        0x22, 0x08, 0x14, 0x22, 0x08, 0x20, 0x10, 0x02, 0x04, 0x00, 0x00, 0x00, 0x22, 0x12, 0x20, 0x12, 0x20,
        0x10, 0x1E, 0x22, 0x08, 0x08, 0x28, 0x08, 0x41, 0x12, 0x22, 0x1C, 0x1C, 0x20, 0x04, 0x08, 0x24, 0x14,
        0x55, 0x14, 0x0E, 0x10, 0x10, 0x08, 0x08, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x14, 0x08, 0x00, 0x3A, 0x00, 0x04, 0x10, 0x08, 0x08, 0x04, 0x00, 0x0C, 0x40, 0x1C, 0x1C, 0x3E,
        0x1C, 0x0E, 0x1C, 0x1C, 0x10, 0x1C, 0x1C, 0x00, 0x04, 0x04, 0x00, 0x20, 0x08, 0x1C, 0x22, 0x3C, 0x1C,
        0x3C, 0x3E, 0x20, 0x1C, 0x22, 0x1C, 0x18, 0x22, 0x1E, 0x41, 0x22, 0x1C, 0x10, 0x1C, 0x22, 0x1C, 0x08,
        0x1C, 0x08, 0x14, 0x22, 0x08, 0x3E, 0x1C, 0x01, 0x1C, 0x00, 0x00, 0x00, 0x1D, 0x2C, 0x1C, 0x0D, 0x1C,
        0x10, 0x02, 0x22, 0x08, 0x08, 0x24, 0x08, 0x41, 0x12, 0x1C, 0x10, 0x04, 0x20, 0x38, 0x08, 0x1A, 0x08,
        0x22, 0x22, 0x02, 0x3C, 0x0C, 0x08, 0x30, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x1C, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};

void Plot::set_dirty_region(int x_min, int y_min, int x_max, int y_max)
{
#if 0
    RECT *r = &m_dirty_region;

    assert(x_min < x_max);
    assert(y_min < y_max);
    assert((r->left <= r->right) && (r->top <= r->bottom));
    if (r->left < 0)
    {
        r->left = x_min;
        r->right = x_max;
        r->top = y_min;
        r->bottom = y_max;
        m_dirty = true;
    }
    else
    {
        if (x_min < r->left)
        {
            r->left = x_min;
            m_dirty = true;
        }
        if (x_max > r->right)
        {
            r->right = x_max;
            m_dirty = true;
        }
        if (y_min < r->top)
        {
            r->top = y_min;
            m_dirty = true;
        }
        if (y_max > r->bottom)
        {
            r->bottom = y_max;
            m_dirty = true;
        }
    }
#endif
}

/* init_pixels
 *
 * Resize the pixel array to sxdots by sydots and initialize it to zero.
 * Any existing pixel array is freed.
 */
void Plot::init_pixels()
{
    m_pixels.clear();
    m_saved_pixels.clear();
    m_width = g_screen_x_dots;
    m_height = g_screen_y_dots;
    m_row_len = m_width * sizeof(Byte);
    m_row_len = ((m_row_len + 3) / 4) * 4;
    m_pixels_len = m_row_len * m_height;
    assert(m_pixels_len > 0);
    m_pixels.resize(m_pixels_len);
    std::memset(m_pixels.data(), 0, m_pixels_len);
    m_dirty = false;
    m_dirty_region = wxRect{-1, -1, -1, -1};
}

void Plot::create_backing_store()
{
#if 0
    {
        HDC dc = GetDC(m_window);
        m_memory_dc = CreateCompatibleDC(dc);
        assert(m_memory_dc);
        ReleaseDC(m_window, dc);
    }

    m_rendering = CreateCompatibleBitmap(m_memory_dc, m_width, m_height);
    assert(m_rendering);
    m_backup = (HBITMAP) SelectObject(m_memory_dc, m_rendering);

    m_font = CreateFont(8, 8, 0, 0, 0, FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_RASTER_PRECIS,
        CLIP_DEFAULT_PRECIS, ANTIALIASED_QUALITY, DEFAULT_PITCH | FF_MODERN, "Courier");
    assert(m_font);
    SelectObject(m_memory_dc, m_font);
    SetBkMode(m_memory_dc, OPAQUE);
#endif
}

void Plot::write_pixel(int x, int y, int color)
{
    assert(m_pixels.size() == m_width * m_height);
    if (x < 0 || x > m_width || y < 0 || y > m_height)
    {
        return;
    }
    m_pixels[(m_height - y - 1) * m_row_len + x] = (Byte) (color & 0xFF);
    set_dirty_region(x, y, x + 1, y + 1);
}

int Plot::read_pixel(int x, int y)
{
    assert(m_pixels.size() == m_width * m_height);
    if (x < 0 || x > m_width || y < 0 || y > m_height)
    {
        return 0;
    }
    return m_pixels[(m_height - 1 - y) * m_row_len + x];
}

void Plot::write_span(int y, int x, int last_x, const Byte *pixels)
{
    int width = last_x - x + 1;

    for (int i = 0; i < width; i++)
    {
        write_pixel(x + i, y, pixels[i]);
    }
    set_dirty_region(x, y, last_x + 1, y + 1);
}

void Plot::flush()
{
    if (m_dirty)
    {
        RefreshRect(m_dirty_region, false);
        m_dirty = false;
        m_dirty_region = {-1, -1, -1, -1};
    }
}

void Plot::read_span(int y, int x, int last_x, Byte *pixels)
{
    flush();
    int width = last_x - x + 1;
    for (int i = 0; i < width; i++)
    {
        pixels[i] = read_pixel(x + i, y);
    }
}

void Plot::set_line_mode(int mode)
{
}

void Plot::draw_line(int x1, int y1, int x2, int y2, int color)
{
    ::draw_line(x1, y1, x2, y2, color);
}

int Plot::resize()
{
    if ((g_screen_x_dots == m_width) && (g_screen_y_dots == m_height))
    {
        return 0;
    }

    init_pixels();
#if 0
    BOOL status = SetWindowPos(m_window, nullptr, 0, 0, m_width, m_height, SWP_NOZORDER | SWP_NOMOVE);
    assert(status);
#endif

    return 1;
}

int Plot::read_palette()
{
    if (!g_got_real_dac)
    {
        return -1;
    }

    for (int i = 0; i < 256; i++)
    {
        g_dac_box[i][0] = m_clut[i][0];
        g_dac_box[i][1] = m_clut[i][1];
        g_dac_box[i][2] = m_clut[i][2];
    }
    return 0;
}

int Plot::write_palette()
{
    for (int i = 0; i < 256; i++)
    {
        m_clut[i][0] = g_dac_box[i][0];
        m_clut[i][1] = g_dac_box[i][1];
        m_clut[i][2] = g_dac_box[i][2];
    }
    redraw();

    return 0;
}

static VOID CALLBACK redraw_window(HWND window, UINT msg, UINT_PTR /*id_event*/, DWORD time)
{
    InvalidateRect(window, nullptr, FALSE);
    KillTimer(window, PLOT_TIMER_ID);
}

void Plot::schedule_alarm(int secs)
{
#if 0
    UINT_PTR result = SetTimer(m_window, PLOT_TIMER_ID, secs, redraw_window);
    if (!result)
    {
        const DWORD error = GetLastError();
        throw std::runtime_error("SetTimer failed: " + std::to_string(error));
    }
#endif
}

void Plot::clear()
{
    m_dirty_region = wxRect{0, 0, m_width, m_height};
    m_dirty = true;
    std::memset(m_pixels.data(), 0, m_pixels_len);
}

void Plot::redraw()
{
    Refresh(false);
}

void Plot::display_string(int x, int y, int fg, int bg, const char *text)
{
    while (*text)
    {
        for (int row = 0; row < 8; row++)
        {
            int x1 = x;
            int col = 8;
            Byte pixel = FONT_8x8[row][static_cast<unsigned char>(*text)];
            while (col-- > 0)
            {
                int color = (pixel & (1 << col)) ? fg : bg;
                write_pixel(x1++, y + row, color);
            }
        }
        x += 8;
        text++;
    }
    flush();
}

void Plot::save_graphics()
{
    m_saved_pixels = m_pixels;
}

void Plot::restore_graphics()
{
    m_pixels = m_saved_pixels;
    redraw();
}

} // namespace ui

; SPDX-License-Identifier: GPL-3.0-only
;
~HdrFile=helpdefs.h
~HlpFile=id.hlp
~Version=100
~FormatExclude=8
~DocContents
{3.   , 0, Table Demonstration, FF}
{3.1  , 1, "Burning Ship"}
{3.1  , 1, "Cellular Automata"}
;
;
;
~Topic=Burning Ship, Label=HT_BURNING_SHIP
(type=burning-ship)
~Doc-,Format-,Online-

image::help/images/thumbnails/type-burning-ship.png[link=help/images/type-burning-ship.png]
~Doc+,Format+,Online+

This fractal is a derivative of the classic Mandelbrot fractal with a twist.
Some parts use absolute values in the equations and this gives an amazing
angular quality to the fractal.
;
;
;
~Topic=Cellular Automata, Label=HT_CELLULAR
(type=cellular)
~Doc-,Format-,Online-

image::help/images/thumbnails/type-cellular.png[link=help/images/type-cellular.png]
~Doc+,Format+,Online+

These fractals are generated by 1-dimensional cellular automata.  Consider
a 1-dimensional line of cells, where each cell can have the value 0 or 1.
In each time step, the new value of a cell is computed from the old value
of the cell and the values of its neighbors.  On the screen, each horizontal
row shows the value of the cells at any one time.  The time axis proceeds
down the screen, with each row computed from the row above.

Different classes of cellular automata can be described by how many different
states a cell can have (k), and how many neighbors on each side are examined
(r).  Id implements the binary nearest neighbor cellular automata
(k=2,r=1), the binary next-nearest neighbor cellular automata (k=2,r=2),
and the ternary nearest neighbor cellular automata (k=3,r=1) and several
others.

The rules used here determine the next state of a given cell by using the
sum of the states in the cell's neighborhood.  The sum of the cells in the
neighborhood are mapped by rule to the new value of the cell.  For the
binary nearest neighbor cellular automata, only the closest neighbor on
each side is used.  This results in a 4 digit rule controlling the
generation of each new line:  if each of the cells in the neighborhood is
1, the maximum sum is 1+1+1 = 3 and the sum can range from 0 to 3, or 4
values.  This results in a 4 digit rule.  For instance, in the rule 1010,
starting from the right we have 0->0, 1->1, 2->0, 3->1.  If the cell's
neighborhood sums to 2, the new cell value would be 0.

For the next-nearest cellular automata (kr = 22), each pixel is determined
from the pixel value and the two neighbors on each side.  This results in
a 6 digit rule.

For the ternary nearest neighbor cellular automata (kr = 31), each cell
can have the value 0, 1, or 2.  A single neighbor on each side is examined,
resulting in a 7 digit rule.

~ADoc-
  kr  #'s in rule  example rule     | kr  #'s in rule  example rule\
  21      4        1010             | 42     16        2300331230331001\
  31      7        1211001          | 23      8        10011001\
  41     10        3311100320       | 33     15        021110101210010\
  51     13        2114220444030    | 24     10        0101001110\
  61     16        3452355321541340 | 25     12        110101011001\
  22      6        011010           | 26     14        00001100000110\
  32     11        21212002010      | 27     16        0010000000000110\
~Online-,Doc-,ADoc+,Format-

[cols="1,1,2,1,1,2"]
|===
|kr|#'s in rule|example rule|kr |#'s in rule|example rule

|21
|4
|1010
|42
|16
|2300331230331001

|31
|7
|1211001
|23
|8
|10011001

|41
|10
|3311100320
|33
|15
|021110101210010

|51
|13
|2114220444030
|24
|10
|0101001110

|61
|16
|3452355321541340
|25
|12
|110101011001

|22
|6
|011010
|26
|14
|00001100000110

|32
|11
|21212002010
|27
|16
|0010000000000110
|===
~Online+,Doc+,Format+

The starting row of cells can be set to a pattern of up to 16 digits or to a
random pattern.  The borders are set to zeros if a pattern is entered or are
set randomly if the starting row is set randomly.

A zero rule will randomly generate the rule to use.
;
;

Refactor globals into classes:
==============================
- Identify related globals and group them together.
- Add related globals to a state class as private members with m_ names
  instead of g_ names.
- Create a single instance of the global state class with a g_ name
- Add getter/setter methods 
- Replace references to globals with references to getter/setter methods
- Look for uses of the setter method for candidates to move to the class
- Look for functions that primarily use getter/setter methods on the
  state class; these are candidates for migration to the state class.

Split user-interface from calculation:
======================================
- Identify state and functions used only for user-interface code.
- Separate user-interface code and calculation code as much as possible
- Create two objects for these responsibilities and have them collaborate
- With a separate calculation object from the UI object, there is the
  possibility of packaging the calculation object in a library that has
  no UI dependencies.

Split modules implementing multiple responsibilities:
=====================================================
- Eventually we want a group of collaborating classes, with each class
  having a single well-defined responsibility.
- What we have is a large pile of global functions implementing pieces
  of responsibilities split among files.
- First group related functions and their global and static data together
  into a single module.  Add glue functions as necessary to allow other
  functions to have access to state encapsulated by the module's static
  data.
- If a module (file) implements more than one responsibility, split
  individual responsibilities into their own module (file).
- Converting a module with well-defined responsibilities into an object
  is much easier than trying to extract multiple objects from a single
  module.

Convert polling I/O to event-driven I/O:
========================================
- Identify input check points, generally one of two kinds:
	- Interrupt calculation
	- User input
- For calculation interruption, there is generally a check of the keyboard
  and then some flag is set or the computation loop is exited.  Defer these
  sorts of input situations for later.  Ultimately we want to replace these
  with a check against a "should continue" flag so that the computation can
  be placed on a thread separate from the UI.
- For user input, there is generally an input loop local to the routine that
  consists of something like:
    while (more input)
    {
      switch (input key)
      {
      case FIK_key: handle_key();
      }
    }
  This is almost an event dispatch loop except that the "event" pump is
  local to each routine.  Refactor this into a form like that in the intro
  screen by implementing a class that derives from AbstractDialog.  The
  class represents the current input context by implementing two virtual
  methods: one that processes input and one that is called when there is
  no input (idle processing).
  
  Once all the user input has been transformed into classes derived from
  AbstractDialog, there exists the possibility of implementing a single
  event processing loop for all dialogs that dispatches to the appropriate
  AbstractDialog as key events are received from the windowing system
  event loop.
  
  The main difficulty lies in transforming the main loop of the application.
  Here the user-interface code is called in a nested fashion from the
  calculation code.  The event loop needs to be moved all the way to the
  top-level main application function and call into the calculation code
  at the appropriate time.
  
  This is probably the most elaborate refactoring and will need to be
  performed incrementally over some time.

Enhance single document model to multiple document model:
=========================================================
- Once all the code has been refactored into a set of collaborating
  objects, it will be possible to relax the constraint of having a single
  set of global objects and instantiate multiple collections of objects,
  each collection representing the rendering state of a single "document".
- The model-view-controller pattern can be used to implement multiple
  fractal renderings happening concurrently.
- Introducing a multiple-document model will be nearly impossible until
  all the global state is sorted out into objects, so don't try until then.
